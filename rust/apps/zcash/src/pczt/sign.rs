use super::*;
use alloc::format;
use blake2b_simd::Hash;

struct SeedSigner<'a> {
    seed: &'a [u8],
    randomness: [u8; 32],
}

impl<'a> PcztSigner for SeedSigner<'a> {
    type Error = ZcashError;
    fn sign_transparent(
        &self,
        hash: Option<Hash>,
        key_path: BTreeMap<[u8; 33], Zip32Derivation>,
    ) -> Result<BTreeMap<[u8; 33], ZcashSignature>, Self::Error> {
        let hash = hash.ok_or(ZcashError::InvalidDataError(format!("invalid siging hash")))?;
        let message = Message::from_digest_slice(hash.as_bytes()).unwrap();
        let fingerprint = calculate_seed_fingerprint(&self.seed)
            .map_err(|e| ZcashError::SigningError(e.to_string()))?;

        let mut result = BTreeMap::new();
        key_path.iter().try_for_each(|(pubkey, path)| {
            let path_fingerprint = path.seed_fingerprint.clone();
            if fingerprint == path_fingerprint {
                let my_pubkey = get_public_key_by_seed(&self.seed, &path.to_string())
                    .map_err(|e| ZcashError::SigningError(e.to_string()))?;
                if my_pubkey.serialize().to_vec().eq(pubkey) {
                    let signature = sign_message_by_seed(&self.seed, &path.to_string(), &message)
                        .map(|(_rec_id, signature)| signature)
                        .map_err(|e| ZcashError::SigningError(e.to_string()))?;
                    result.insert(pubkey.clone(), signature);
                }
            }
            Ok(())
        })?;

        Ok(result)
    }

    fn sign_sapling(
        &self,
        _hash: Option<Hash>,
        _alpha: [u8; 32],
        _path: Zip32Derivation,
    ) -> Result<Option<ZcashSignature>, Self::Error> {
        // we don't support sapling yet
        Err(ZcashError::SigningError(
            "sapling not supported".to_string(),
        ))
    }

    fn sign_orchard(
        &self,
        hash: Option<Hash>,
        alpha: [u8; 32],
        path: Zip32Derivation,
    ) -> Result<Option<ZcashSignature>, Self::Error> {
        let fingerprint = calculate_seed_fingerprint(&self.seed)
            .map_err(|e| ZcashError::SigningError(e.to_string()))?;

        let hash = hash.ok_or(ZcashError::InvalidDataError(format!("invalid siging hash")))?;

        let path_fingerprint = path.seed_fingerprint.clone();
        if fingerprint == path_fingerprint {
            sign_message_orchard(
                &self.seed,
                alpha,
                hash.as_bytes(),
                &path.to_string(),
                &self.randomness,
            )
            .map(|signature| Some(signature))
            .map_err(|e| ZcashError::SigningError(e.to_string()))
        } else {
            Ok(None)
        }
    }
}
pub fn sign_pczt(pczt: &Pczt, seed: &[u8], randomness: [u8; 32]) -> crate::Result<Vec<u8>> {
    pczt.sign(&SeedSigner { seed, randomness })
        .map(|pczt| {
            rust_tools::debug!(format!("pczt: {:?}", hex::encode(pczt.serialize())));
            pczt.serialize()
        })
        .map_err(|e| ZcashError::SigningError(e.to_string()))
}

#[cfg(test)]
mod tests {
    use alloc::{collections::btree_map::BTreeMap, vec};
    use keystore::algorithms::zcash::derive_ufvk;
    use zcash_vendor::pczt::{
        common::{Global, Zip32Derivation},
        orchard::{self, Action},
        sapling, transparent, Pczt, V5_TX_VERSION, V5_VERSION_GROUP_ID,
    };

    use super::*;

    extern crate std;

    const HARDENED_MASK: u32 = 0x8000_0000;

    use std::println;

    #[test]
    fn test_sign_pczt() {
        let pczt = "50435a5401000000058ace9cb502d5a09cc70c010092dda70185010001227a636173685f636c69656e745f6261636b656e643a70726f706f73616c5f696e666f140cd612b51afd462f8b19e3edcaf79157eadca7010000000000fbc2f4300c01f0b7820d00e3347c8da4ee614674376cbc45359daa54f9b5493e0100000000000000000000000000000000000000000000000000000000000000000248f5fbabcfab48f0f81f210e7b6bc4e9bdb3a9be5ff0018f9e190f7072e78d3bb6dc07e492c92d702a85fac123a1847a6f651e00f8905d0e437ed33fa9def418e7b457e8a6b65862a31d56434817f451ebab580bc2fe374fa96f01cc0c3adf37000114b0cac3e14c4e1a4a4fd22c98563b9cbe859c67768a39f67abd5dbe55d3d16ff58e5c45b21d8c573f54b901e0f5f201012e37833cbe331fe961f4adccead166294519a354f2ee72022fbffafd660424000126639c70fd66ea727c38e7bbcbc185f69eab410d41c2cf1ffa799deeb0cae9ce017d6d7535f6e3eade13042662d05eefa91d1f4757fcd0b4b844554e77366f4b36a7068e15c2f06aaa11f6bcfd2e9e36231530069f7fb99a2771050689f24f332b427fdd05d1d5f3219230a1406f0955e3ddc0ef5ce2c7f160d797f3e54ef5782001d9a3ab170d54720a916ed11694a363087edd33e80c4fba5b99ab4e268844c626e095c6147f90aa00e564894d523d591803c3f70e5f3cf0b78df11c30c692eb53b61d570fc4e15c65718ddb408e62add513bf87284e72c4142fbe75e92e18d344fb61b11769c751e83f12141f7ba68eb0c19844adfaacccf642609a1f2773cce422f7c31f04e8bd109baefd7739b9c48a570c5e4d613d9f2b5a0621b61a4e7eda788c1b1bf44905b00a67e2474ffdf203cc9bd32e593a741ed1dadf5e0a2c3cf02a9d82393100c0297533ab75c22b113db4693d8cf61b21570c1f21edf89477a2e7bf740cb1e779f3088da9819a590c5474384ed04d724606a76ddf80036e2ac52a8fa7057aa0667da7c4ef890f2eab3c5892e39be29b020793a5d3f0f6f3942981c26a38007ab14443f4b375536142b59f222f5337bf4c671bd6f57aa3fd5e050726dc3c53fd99c2e7156a1092c95bce18d9e2a5cc568a96556430c1785958b26fb22b12eec609dbfb205dd0c6675c576ea301bf0aa397c4cd383f6ace064434e405b5093c1d81175c618596a01ecadad95d75fee2eb4390fef14a084ac781b79e487f0f1dbb6c1523d9a86316044757219311a23d5ad6e71d34b8f6a2832494d2b98d3d7597692c9b1a0b7d4bc8e93db1c90c8331e9709ac9973ca3fbf38b2aa955382b0c104faa2b1148b1b627090aa939e321b82edcb0ce70aa4eee298997556b4f358449e7d9f0bcb971dcd97024ace98fe01e7c6d96d6fb235fcbcfef949d71f12912278dfeae9949f887b70ae81e084f8897a5054627acef3efd01c8b29793d522ca2ced953b7fb95e3ba986333da9e69cd355223c929731094b6c2174c7638d2e60040850b766b126a2b4843fcdfdffa5d5cab3f53bc860a3bef68958b5f066177097b04c2aa045a0deffcaca41c5ac92e694466578f5909e72bb78d33310f705cc2dcaa338b312112db04b435a706d63244dd435238f0aa1e9e1598d354708102dcc4273c8a0ed2337ecf7879380a07e7d427c7f9d82e538002bd1442978402cdaf63debf5b40df902dae98dadc029f281474d190cddecef1b10653248a234151f91982912012669f74d0cfa1030ff37b152324e5b8346b3335a0aaeb63a0a2de2bca6a8d987d668defba89dc082196a922634ed88e065c669e526bb8815ee1be8ae2ad91d463bab75ee941d33cc5817b613c63cda943a4c07f600591b088a25d53fdee371cef596766823f4a518a583b1158243afe89700f0da76da46d0060f15d2444cefe7914c9a61e829c730eceb216288fee825f6b3b6298f6f6b6bd62e4c57a617a0aa10ea7a83aa6b6b0ed685b6a3d9e5b8fd14f56cdc18021b12253f3fd4915c19bd831a7920be55d969b2ac23359e2559da77de2373f06ca014ba2787d063cd07ee4944222b7762840eb94c688bec743fa8bdf7715c8fe29f104c2a01422e35d9895d15c28e4f72c0e664a3619d181e2a6e49a06a01eaea82d8c5fe19012fac20755b7bb7c99d302b782ea36f62a1b0cfe8d7d4d09a58e8ba5da26f457803a080808008858180800880808080080000d7c7a57b6e269cf6cd8779d931b0a65483d6277b5904f346516eb847cda0f41ef2d0853dd79541a3f47e437de217c05a1bc6878794441d49c0ae29c43a1f49a5c404f19d637f63c1ca41a49da057411bce72ec26103743c1610e3ac2a2d03ff9c7905336bb908d18188538675704fbcf1ede853596846bd86411411d4c227c29174ada099d9a7758d1119e4afe3eb33e4ecd85c8f2704dbbdef80a4cddb9db92e2b513bbd576c61733425278813a904a515e655586fcc72a73c7b104917ab2e0fb2f706451ebb1847eef52b954af6a61e581757550cdf558e9505fefb91f107bc4cc97101b71880364f57dde3002db3b10a6f5b13d9b350fa2f7b6c01dc2ff8446b20fc6d81b76295f6eca4d4df43a10008251031725ce8182ce9f7dd8870ff86857d528c78cd76b10913196b1a8c1cdf1bd432323c3d92124c0a947a419f133d1df6a3d7ca7cb45ece70374cbee975dbfe2c489e01f568d9308cf52fb1ead544c4339079f32dd58bdcc610974e8cf482c65244f0d292053ad6e3ec5470653384624420e06c007f6d1c07cb9f48d8dc6d6059fe6bf958d2ceb1581b8b5e443742d6757de3f2cc744d57e6e6a49daf16fb296cf4f1b0a92a560ffddce81aa407753210512aad107bbc0d5d0c9fe09470f92acdb3291af21c34f541546f5de2ae09b8b3fe645605665d00467f540c7fb4bdd7fffb8a7f1a1dd0f7e0e23b9244b4fd9a554707673d31c67c9558a7bacd532585640b0d0e9aa8717e4519bce5c42c4c0f5ba41b66c49e4f17245e38062d1414969961dbc1180ce84f3bfd4d54cb73e0c0d44cadad0f5815654b3c596ca2ba9885b915adc55f4e8800c73f5cf23f07977d8fca50fc2c458fc7ca185ab2281e727eba6e4c3b712c12040f861cad1e8002828c0bdcd0d50a5efc317a42fbdff314681dbaee8f323eebcd3eb7147a57d2d61119d7c42cc1050d38bc6b631f6924c80cd7dfa47117f788fdbcc398fbfb3b03450f475bedb7d2eba077b59b3cc9a21d417526d43c1e30114b0cac3e14c4e1a4a4fd22c98563b9cbe859c67768a39f67abd5dbe55d3d16ff58e5c45b21d8c573f54b901c0d9f1010103031340066f28afc325e52e4fda0f3374c56d79c78c722ba40f674a691ad274000001207a636173685f636c69656e745f6261636b656e643a6f75747075745f696e666f12020cd612b51afd462f8b19e3edcaf791570001b77a4338d47b31f9417cdcff3b64cd5b56ac29a1c8fccf88196e5cac18c4950fa575f542f2e258a2afb3be0a6d09762db5621be58132de59f239e4ce1c3f7fb98e8021c39a7fe35e4f7e0fd8ef2705ac9450e519ed583d8898a1bfa133c95d3d06c3d40a98f865ccb24e622f3084891f59c8cd61476794b210effd7dc0d399ac01d045bccb48fd21e4d059d296ad228e8f02c5fa1586e8ccbb0dcd158fc9faa291b8041d6d388f256329e3f52784a85a6501a179cf2c844d10461b30becb2db90e0195676e6987be5dd1f0766b98ffdb212e2cc81d7cc9cac00fd72ca94c1dc95b4bf94e6ed40dad44aaf961170100011f5a262c895dc5ebe44c979755cab722a6bd9f9df0b330215dd1e156e73d412001ed6b3033bb57e2b56f8de4c795e9f17f4a84b8662b6a0d8b2f0c7e4686305593016c215f6e30d62fd4cf948303c0ff45d849167b3c0ec10200e5bbf3cd92533734e4bb8056307ad10d2ed368dc582bdabe318d5bcade1bb2c5bdec667f7b676632e143078f0205b7cfd2666ac62d55d629364bd885e4deb3b53e6f522030571e06019af38db8054d2c7ac8284cb9b1f640b971d1985b4df06e562e56e3507692204402d215bb38b8b3922497a5d25674bab58dbac39ce22e9da3401fe22dddb4df2b66b941683bd94403214032a67899b2188e3606b210f30da22134824daf6d3eaea26ea48313cfbb5c9202071fedfe67ea5459d9b64e289e114286aeaafdc925b6f0e3e22d04c3e44961598644b2c1823cc10a88ceeaa9e0baaca6a88781d07c4c44e215a3188421c3f3e98870feaeb644289806cc0dcc614b5807bb250b6b77dc7541f4e61b2740bd9d4553fe455a63d952ef933202777ac84817d9037b94994bc73bd0a53070fad69c2192e7c9fd420d5d76ef381b10cfd5ad9cf7266d33b617b8a27b8d05fe2f5aded2047645608a668adb5e99afd1287d3a541b63ae3034d97dc354a0110d58817a633ea5dcd91c79ead3dd8686ea1e32d73883b03871134e34de11f92f952139b5708555318e1799cf16882180b13996b529a50da7ac0c74847f9d160983ae377789e1f8e7a4455ef31552ea3eb8fbb1d104ebc75afd10a9cef5f0f12a3a908ffe2b7495fff8912428bbcfa1fb2f5efe9444503b4a78326262e32bdd1f166b41a8b0015d87aa777a506e93dfe5597917c1a5ccdb0d13f1e3ccd491431e2691c8ab5baa24a430d3becbdc7171d026ddf8a6a4357fd5508995d36e033b3d3a5ff7ec5c680599dc339ab5fd20842e391404934a615cb4416e22f37bb97b2ffc5470259a80d9f4ee26410c6b164a71bff1b3e9731d3e08d09e2ad47b190311819099d92403ec77099025a85da9eb09224146b111c9bbeaf879f84370f53b3b6bee68b017e414b1cf8b5c07a6855e35ec48d2f93e632645633a63e5d3b6291af483b62e859d541aef33a71196b5934fff89d9f05b3eb06e27fbcc2b239dcd1e0635ea1ac5eb429dda2846fccb2114b635dca74ca2934a54a6f73b7ce0a9930686ada39ea0958ecccb0f4179e0618ef3fa83b1136328fd56d0967a9a287abf0605930cb48c7d9553a59538da183cc28adc3be32a875ce86d2d806875d69b511fb5da89e1f82453edb15f4f9ab90dcb40b0846c3085d1984a40cb96491dbf4e08cb03540f9a00eafb3177daac3bcb6c675da4eba12afe6b88944e56df1bb5a52489ea4e66ee092f1c120a9d06b98e007459ef6170f857ee838e15ff995d13ae2098565744ae8b8f8854287fdc7f65d80b0d49a4229a341f2fc16d0a7dbc4213097e06e17cde24b0b05e5bb615da1069d8fe5468d674049ebf71d8905fc8e2332fc02d7883fe82b2b115375340d38d26f0bd72b29e10167022afd121aa836e2e0f7ee6f02d8722f2e908b65e62ab60ec4ec6a2e413931e57386241ece6e4d8202a96e12a4d6ac6d09ca68bb41c88f2d3089e485fb09555c542a47166fbd3b91d17f517c06997065c85e2b108740c0d8eb24a72928e13227b4239ee2a380286081901c2ca4cd85d8df2749700103665ba4d3821d535e4c0473b5574f163d66f3cb92f012fac20755b7bb7c99d302b782ea36f62a1b0cfe8d7d4d09a58e8ba5da26f457803a0808080088581808008808080800800005716212c0a7d26f17c87169cb4f183c87442246685bf85eeeb24e1ab77e8d01877714e36f47b331940ced47aa97e745f3258a535daeaa01191c0ceb7e7e8d9b5c40490d135d8df82e20561ab5d69fd3b0a2afb462df8092b9176b6ce9d2cfeb7ddce2879d36181128f182cb636ca25835be79c86af90569c77254a094271ace1c8cfff4af4cf4f381c1c293abe2dda35965a59f981de14506350bc8381ab776cc1275146bb5bbfc5fd648d5e148a0554f8a556e6cf5651a0367e65c1a265b8105e048a07381e195fd470a5d73706f3f0d9f8579c47eac3cde9eaef7208555bd9ba87431805c831142ae5cc895ff59b4970f76b8c725f81a47d4ef54ba8301a9502cf231e25d24c473ea5313c6d989e54728f66246b4375936d5475e3aeb9d94a9972e84c0eeae11cbf5d491430f2a42ec4ccc0fb8d44c905e3851b82f31f8347b8deaad9f331fd3892b77e7aa58f7bc97671e6ff2a3cbd95d9eea4a6b3720a7228159feba56e434c02ad8ef4ddac023170a96eee1801e403f858cc2beaf3f55500bc1b9787ff519a8fff8efa8293c90d5d5425eb678fd8d9815beff8070a014648bdaf65c65717babde51c26577d9e95e249f58d1a0fa8af650a80572fb38990bf40cd7445f980f6cc4a0e4de0c0cf220da4d9d6860ffd063fa102797062d63730eda932d961c8f786e73023d7fa46d653977ecf71b9b24ee54ec2a07883e3c5f454bc74322bcde660d9613c8122e2b39e09a152bdc8a5baaba655d1817a7273feaba854706fa5629142f221056a3cc8fa9bae98ce69f77c5425edae55eb5d5e8b33de7b63becb4896de2fbf9da6e1a43c91e8311419b17752efa129cf3514d4e1dda9697e454b486449e2755dd494c0a12f6481ad3ff4ff7baa9900d121b4afbfb724a673cb501d222ecf6d439f8ddb1aa4643d0cd90e4c873fdafbcb31300f0d11a3674dec4672f3779c205ec2a46912a3fb67a547a3b8ab43ba0ce3f6bb0f276ea61306d1e4e73bdf5703fd221923ef76a9cc49f2aa0199a66f4d2212d15f6b9ddf1d738b41226e3954130fee9e1654409d3eb52a82e0e18f62bb13bab4f37db92901904e012d4e2731af2c3b64f3aaf85866655d7d1a1817ab46125a4f8c56faa8231c31ee000001207a636173685f636c69656e745f6261636b656e643a6f75747075745f696e666fd80100d50175316677787573387a63687136343772346a61717833327537736a32777479706c7376756e336a6563613272633477353575387572736e337132773438377634756d6b686738776c727465726e686e3064776761707471683537327566306b357078736d717a75726633336671677868353375616a6b7472683377733735677766786c65677537686e676839726c6c743635636e7568393675766d65336366346b663366357938737936396a39356e6c7370726176396d3977336d7a6c336b757663306d6874716d3074746c71716a6d786735357501bdcd4e998f0a8b7670e3a9e8b8dd6f86607a8404e47d7bf03c8c42991a37c20e03904e00a5352047e2bbef44cefe58d8b14b140dbd8ea88bf69c0c1d19fe7dec221984130001744892d16386bc6fb25f86e8f4413de2b626aea5ac7a4b7956fa9e4533fb571e";

        let seed = "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

        let seed = hex::decode(seed).unwrap();

        let ufvk = derive_ufvk(&seed).unwrap();
        println!("ufvk: {}", ufvk);

        let seed_fingerprint = calculate_seed_fingerprint(&seed).unwrap();
        println!("seed_fingerprint: {:?}", hex::encode(seed_fingerprint));

        let pczt = Pczt::parse(&hex::decode(pczt).unwrap()).unwrap();
        // println!("rk: {}", hex::encode(pczt.orchard().actions()[0].spend().rk()));
        // //6122d6b5ddcc9eb600a4cedb98932b3a7edf6e8b51bc4478b296450bda68c506
        // println!("alpha: {:?}", hex::encode(pczt.orchard().actions()[0].spend().alpha().unwrap()));

        let randomness = [0u8; 32];

        let result = sign_pczt(&pczt, &seed, randomness);

        // println!("result: {:?}", result.map(|pczt| hex::encode(pczt)));
    }
}
