use super::*;
use alloc::format;
use bitcoin::secp256k1::ecdsa::Signature;
use blake2b_simd::Hash;
use rand_core::OsRng;
use zcash_vendor::pczt::{common::Zip32Derivation, pczt_ext::{PcztSigner, ZcashSignature, TransparentSignatureDER}, Pczt};

struct SeedSigner<'a> {
    seed: &'a [u8],
}

impl<'a> PcztSigner for SeedSigner<'a> {
    type Error = ZcashError;
    fn sign_transparent(
        &self,
        hash: Option<Hash>,
        key_path: BTreeMap<[u8; 33], Zip32Derivation>,
    ) -> Result<BTreeMap<[u8; 33], TransparentSignatureDER>, Self::Error> {
        let hash = hash.ok_or(ZcashError::InvalidDataError(format!("invalid siging hash")))?;
        let message = Message::from_digest_slice(hash.as_bytes()).unwrap();
        let fingerprint = calculate_seed_fingerprint(&self.seed)
            .map_err(|e| ZcashError::SigningError(e.to_string()))?;

        let mut result = BTreeMap::new();
        key_path.iter().try_for_each(|(pubkey, path)| {
            let path_fingerprint = path.seed_fingerprint.clone();
            if fingerprint == path_fingerprint {
                let my_pubkey = get_public_key_by_seed(&self.seed, &path.to_string())
                    .map_err(|e| ZcashError::SigningError(e.to_string()))?;
                if my_pubkey.serialize().to_vec().eq(pubkey) {
                    let signature = sign_message_by_seed(&self.seed, &path.to_string(), &message)
                        .map(|(_rec_id, signature)| signature)
                        .map_err(|e| ZcashError::SigningError(e.to_string()))?;

                    let sig = Signature::from_compact(signature.as_slice())
                        .map_err(|e| ZcashError::SigningError(e.to_string()))?
                        .serialize_der()
                        .as_ref()
                        .to_vec();
                    result.insert(pubkey.clone(), sig);
                }
            }
            Ok(())
        })?;

        Ok(result)
    }

    fn sign_sapling(
        &self,
        _hash: Option<Hash>,
        _alpha: [u8; 32],
        _path: Zip32Derivation,
    ) -> Result<Option<ZcashSignature>, Self::Error> {
        // we don't support sapling yet
        Err(ZcashError::SigningError(
            "sapling not supported".to_string(),
        ))
    }

    fn sign_orchard(
        &self,
        hash: Option<Hash>,
        alpha: [u8; 32],
        path: Zip32Derivation,
    ) -> Result<Option<ZcashSignature>, Self::Error> {
        let fingerprint = calculate_seed_fingerprint(&self.seed)
            .map_err(|e| ZcashError::SigningError(e.to_string()))?;

        let hash = hash.ok_or(ZcashError::InvalidDataError(format!("invalid siging hash")))?;

        let path_fingerprint = path.seed_fingerprint.clone();
        if fingerprint == path_fingerprint {
            sign_message_orchard(&self.seed, alpha, hash.as_bytes(), &path.to_string(), OsRng)
                .map(|signature| Some(signature))
                .map_err(|e| ZcashError::SigningError(e.to_string()))
        } else {
            Ok(None)
        }
    }
}
pub fn sign_pczt(pczt: &Pczt, seed: &[u8]) -> crate::Result<Vec<u8>> {
    pczt.sign(&SeedSigner { seed })
        .map(|pczt| {
            pczt.serialize()
        })
        .map_err(|e| ZcashError::SigningError(e.to_string()))
}

#[cfg(test)]
mod tests {
    use alloc::{collections::btree_map::BTreeMap, vec};
    use keystore::algorithms::zcash::derive_ufvk;
    use zcash_vendor::pczt::{
        common::{Global, Zip32Derivation},
        orchard::{self, Action},
        sapling, transparent, Pczt, V5_TX_VERSION, V5_VERSION_GROUP_ID,
    };

    use super::*;

    extern crate std;

    const HARDENED_MASK: u32 = 0x8000_0000;

    use std::println;

    #[test]
    fn test_sign_pczt() {
        let pczt = "50435a5401000000058ace9cb502d5a09cc70c0100c880a80185010001227a636173685f636c69656e745f6261636b656e643a70726f706f73616c5f696e666f148c3b8fdb49a840dbade76e60189071b1a080a8010001a887151976a914dd4659c045ae47fb65fe1a2bbe04419594d4989e88ac000001207a636173685f636c69656e745f6261636b656e643a6f75747075745f696e666f2500237431653362636d746641785970394876696969444c48684d3179437971536e637a6475000000fbc2f4300c01f0b7820d00e3347c8da4ee614674376cbc45359daa54f9b5493e01000000000000000000000000000000000000000000000000000000000000000002d530415db788283a0ff1684005fdf6de77a8e04cc7627bbee487ffbd77ab181b96b5a4c54c325e400721e03e7384b38deb3c01d9a7b9fc19c317287783611c20034ca6aaccf26f9b975e55ea7282b54e269f0deec3b655cf8eef57ee699be6ae01d46de29630127b47c341ef8d58edf1064ac36b2259d6564966eed56306973a1819a9339daeccd7df49c5c0153ebf1f8c7f7c4c26008036c4e004635b156bf51a01f52f84752eaaa5bb37b884d93918299141dcbf64d718512d954e6f86319486e165663497b0a4a125f329bc01000150010c2e272771e35eb0d4e678fcd8967b8c0b777766bf749abf1c1d60c46c3d0132135fa7e07e91e9683a6165635e681ca514d9b5cd7d441c409f5d4495e8eb24012343fea47af3d05d717be15bddb21123f87d8a64c5dad52bdbc3235783aeeb2d15ddadd71e07944987e6cea70401ffd8e1c766734474e9caff6b82c34a28d7109f196462935445b86c435d48927a810eddcdadd28242d076936cbcfaf8e44a1f01ecade0bb0542671eb7dfd23e4197bac21cfb5d1ed986806d2f1b879a45a0d76f8555bab0302b546f06037f019fc7a482aac008d7ab9715f7d220f81dbfa7fc292f4887d91482f23ddc38c04758293565be5a38ea37f0e582a647232c814b5264a23f428d054de263f868ed39eae80d5140332aeb11009e841f581c1be6c8a72a870d56192d0d20fc0287aa73c9db923af5d42cd1d77aaa80f1d7a4801dedf8053498135502e342809add72f57625442ce09a8a60ee9a5e68f7f2f8b259641f4b0ca0be1b2729576e85974e7607ecdefab92824ebd32d28ead0a63dd21e6d6b8bb52f9d4d08d4e170c1b7f4a4668e561e91c7843d3831747af2513174435f1779d737c70f3f3eab37c33a829221b6c666bf8724a7db3b58a5ce5f34ff4f671aae68cdfe7230ddd15d89fe8be2d984dbd74045394ce33106f5d8f9cb966df646f5e09415193c2274163c9a8700e69691d10d391595d3a6208144a41128618f996a2103b0903cbd02041d7d9c51d194ac1dbd6bbfd1b19b297afe57f9e47c1d1e8c195646cf2a57efffd80a8ea1b3cfc962dd1e15f55e1490a4b3988e14c3aab95686007fd906f764b688b5da1a81a05f4bbdd57278f843943f238bdf46475642d6ef02496a25b4451b59f2767d42aff4f88fe93d41a4e9cf6d03ad60445ab4f315ca4ec9ad1da6c67cf21cb8caef92c743405b6d37aacf7f2caf6383abb39af73d59856290177b729e1f1e45a530e74680b7e7ec48ae3055079aeb7b3c6569b5fe354a3d41044a02abd3195381c56d137d6c2c5a592a060f7ff4f8af4b3fd87503d237d7531b42ddad50ac107b71aba8aa1b667e099a338184890e9564179868e0644fc55500abd9b3fcfe00969b4057ed2b23ed47a8f55a40043822be4835fb990966f86b2a76f5fbab0b11496241c2da7f68bc6370a6be14cc569197c83cd7cb9f2b66d41dce93c09b39c435cda44a2eba90248c102395b36d15dd7da95b9070c2655a832a17416d3c3ed2c05819f19291e6c2f099358b979db06e65063fff33faccdec437aac7b0992f4c8a1b2433e7930fe3e7e56298f50585e7ec49b6e05a5d0903f03929ff0cad3902c79839451d5573043f44d660a70512348a47c94d4dcc0dd87510dfa1737592296710489fbb6931a1c6ee1e150579dbe2a0d22ebd841628638d32a45210f02435a92d107bdd8cbf14ea0a5b5183a57e7b8dd1568c76efb108ab17bd7bb5bdc812da6e79deb690773f31a1b0daf2e3b43c4448894e2d57fba5110bc6f457f91afb2c205508f8a2e0536858343695e34eaac7610bf34c0b8608c22d37926073dfd40f3afd6d40890130cfc09160d7d4ad1c42701d49019f5e60931b77fd1951d976c5a640227d4ae60cbc88321f46de449c61d1593a07b86bf8aa260e522542d496b34b72f3681c366e162b7aa80c1b94f0c4034ca13b19e7d3322f01e451f8823b58b7197f49ad927827dd89115010feb5af05ec7398de60025a842a000000053cc4245ff588abcefc46150b2e9935d68a72e2bafc0635b5b49801773dd8359bf103963d8e1644d17dd274fd955c97ac453f97ed37486391b53bb128618798c4045c222279f9db5db82a329d092ae2b46ed94645be947f55e775f268cb11a9bd3fcc86714c5f823ecc7018e541b00a1dc223561953b208032c0359567f3d94492d4bc829bfa7e44566e690ee4f4b26486b3b5c374f791f62b0d6c71d08fd135d11af2b4ca114fb4dd310f2746dc2899546ff4bf9758c892e6d8b46bb33aa986c86865c6d3557828d5325f7c8053e53b65c09bd2921a3280e5c1f4e0fae5c4acde3b979420979f90b648842b73aae55c36fc72613ac7952fda9b93741ac3c804f52c731d34fde7ea2592eeacef2fe44226dc511124137a73f4414d0a49d3e7007614234c2c210fda57a9e2d321ea68d53186f2aaaf5b3590bafa33cfd524f4a9d67bc3937b4c1ef2391f639f4ec3564a45d3713169fda98be2f4d742eb629df30c9f58709e87109b7e3a8b0a0d01df077a00d4862a0e522f2e73f6d6dc3cc9c3728489d8eb0b64cfb4aed5668971008a9570c444b5cc84dfbb14fb5c2cc38bfe0a09855cf622eda2dcce2178a55613ce0d1d155d84902e796869445944141ead3bc5e651f20ef6deccd229d198530df600f35c88c68d40bb4f5fefba7fbf47660c8475dfb562d23068b8ad7de28be6eb2ef4b93fbf4d51042853a72ce1d22512a98e18f4002aefa8813ac7580627c5c5d2e7b3d12f079d40dc7c5ffe973fbd5c0fb9745b0788dfa01182d1b616bf61d69eb083da4b3d87e8b154bd0f29b11822e00c36f45d732550248ba83438262859c8ec3c10503df854d45cadfaeb6f57e0ff16d126b6309caaccccfc98745f47017b9355733fb0c80c119d809b607da69c533f292e68c50166224e4e1adcfe420d04d6f200a8b4d4aff5539029828336c9fd208677adca97eb210482c95243a91b08f956a4a049be350b2ba903dd304065d2e15185855e29f1c3750ca459de12e00dd6387904713010abd4cc6390571dc93f84f9ebeb61bc5590b65d53a8bc042cfc302adfb8450ae77b5aeb84d612b22032a3901000140d238a9a4b7bd8ed6a99c32dd026dba535a5be51c4a7462c2df18c507b6962900000001d5fdd83ef71600d98e6a9adf0d7e5e4d724ced2ae1cb94583034fe372d16d217492bc059e78ad4e138d8ded181e33432dfd1eb612faa09551c88d24d72e8dc95308b59ced8eb8eb76fa716a72d392b2374c6652a3fb5491649daa854fcb0b3176f135ec608ecd32655cfdf9b3b124501d751c463704ca6bbc91cfd6835ad82110001a6e4300a17750f9a93b123a762950633fe0e507065c3443b147b14642b21823b57f468fc7d7579fe8bf68401c0dbb90101186a5acef5290ae35717f7140c5ea7f31c510130720c8eaf523fd9b3327b11160125122eb8938c602ce1a6e3ccbeee0136875fd0fcebf62a74a81f9adbea16182401677c12dfc237d005428692f80f9bd8f35993d0437f4955d55cf64b4a027ec92059ac34cdb5b89e2db8130175daf8e5d89cb65eeff6a1a21261aabb60ed6c1012e0657719566e48433da7a9fa319b23bf9e783b11047f1ed691b7164da32fe1120195d6ac1721261440becdda214ee9891fed65d25ec162190f86710649370e396c471dd02e0ed4b7acafafc18e30d7c6fbe1b972d2ef593e3c0ea38e492693f39a02182b334c6c974c1ff99e3dcffb2e93c42f263b8e939a6387f890bf15147147a928e82ef7e356a0b92dfc0b64f5718e8803d8dcadbe01c02e6118d5960039c271582929ce129a684a0c3d3eb92030420ae96046684f0b54bf76beb7cf402717334608310566f6d9172f9f8d4c323c50c10647320b20eff2b9f5f74aebeee3cc2b245a32e41626029af2cc80d66fef6aba8f2b151b9e9933c5b7e22eee53c498cdb1f705909e7ec3aecc6dfd963c0a176b7c2e431ec2cf0e33178b3de281d09e20a7ad2cca618bc84f9e7a7ea41490d4032efea61200fe9e827d32173f69113fd27d0d334d2d6852d19bd214f7729644b2b68e9956ad31be510ca7d5329b7d647d34101099f75785ef17c5a0c2e52b63bf64f9e472348b1c926c560bf3e1b56f5f055426fd8d40ccb9fb2e104aa0357a122141052c9a741c4c2c736b6dd0363ddbf27e2922ae2800cb93abe63b70c172de70362d9830e53800398884a7a64ff68ed99e0b9d2e26bdef115ced7bd36305a54386996133c4e65759f3731637a40eba67da103f98adbe364f148b0cc2042cafc6be1166fae39090ab4b354bfb6217b964453b63f8dbd10df936f1734973e0b3bd25f4ed440566c923085903f696bc6347ec0f6f3f63aab58e63b6449583df5658a91972a20291c6311b5b3e5240aff8d7d00212278dfeae9949f887b70ae81e084f8897a5054627acef3efd01c8b29793d522ca2ced953b7fb95e3ba986333da9e69cd355223c929731094b6c2174c7638d2e60040850b766b126a2b4843fcdfdffa5d5cab3f53bc860a3bef68958b5f066177097b04c2aa045a0deffcaca41c5ac92e694466578f5909e72bb78d33310f705cc2dcaa338b312112db04b435a706d63244dd435238f0aa1e9e1598d354708102dcc4273c8a0ed2337ecf7879380a07e7d427c7f9d82e538002bd1442978402cdaf63debf5b40df902dae98dadc029f281474d190cddecef1b10653248a234151f91982912012669f74d0cfa1030ff37b152324e5b8346b3335a0aaeb63a0a2de2bca6a8d987d668defba89dc082196a922634ed88e065c669e526bb8815ee1be8ae2ad91d463bab75ee941d33cc5817b613c63cda943a4c07f600591b088a25d53fdee371cef596766823f4a518a583b1158243afe89700f0da76da46d0060f15d2444cefe7914c9a61e829c730eceb216288fee825f6b3b6298f6f6b6bd62e4c57a617a0aa10ea7a83aa6b6b0ed685b6a3d9e5b8fd14f56cdc18021b12253f3fd4915c19bd831a7920be55d969b2ac23359e2559da77de2373f06ca014ba2787d063cd07ee4944222b7762840eb94c688bec743fa8bdf7715c8fe29f104c2a01b8bcc047c60cdd893b4ef0c83b4eea4b57d2fce354315c764d5c935038b4c12b011b290d0b4449383e1f899dab47bfa689794f15673c4bba95eed10e14ca5aa95303a08080800885818080088080808008000062585f49df8bac9476bd813dfd1bcb094980f74665c4479f1daafe68f58baf2e949affb7d48056e73488193a804a5ac0041f42bfd61850aca5c714bd611cdf8ac4049827b67de43462e650a146ed6f3390fe64bb4cff34dc05168f8be9658fdeaefa496dd7070a61a7ba24c47620a7b6c6c0acc9243c94fccc855703ace7531f9276a7105ebe8c604900575dd37e5725dba529ec2352c9696372c95db24e7963b5e0200c7881a3338c7bf6c0c308b8145fb7f2f0a35e3c24049e403a9ae6105181cb6bbd69b93f8f1d92bb3d0acf4d0b00b7728b1300e555d0fd7f90ab129f7b224eebb63831d9a3baa912f65229372684802746257e0b752cbaf88c0ea4667e662abce4038cd046d0ab60ca59996c35e32385a1a495eb7c1959aeee114166fb9bd27484f78c1f2b1bacb625eca76e735cf523d634d37e562f5e82cb2dd4fc5a72f55a23562fef249b62ff79cdfa87817eb0dac3cf2391280cfb6be70e8ebdbcca3a47b7e0cd5ff46885ce03b13016f5b9321e65c9f5c2a1f816ed9e5bd7ca4f3f9ff48ef7ab0cf2b727cb8879abbb6ebd426bf49ce76b18261a0c8036d1e52f1a0037306a67cec51719ef53c85d01a9001d78578dc9533ec3c231b82df9eecb6c93433c1428285271d2edfda466826cf420e663b019f9fedc03162b68d7e7095db91bb65ddd3bb05010fda74dd40861f711a1c7669bf8210acb9ae4bfec9b00e35884224d0c80f3bd600939c5dc32770e2fb78631d520db5d514c82642cf12477d95b835097d565c65252621054517ba768db20b94057b940d769a6426c0fa627bd39289add94ffbb4cf5a1c15618b9d8e032f529d06b086417650bd97f1abe1e70145f88943b58622fd66f5f9caa778605706c19b07033da451f4e9385256719964cda853e50d6d7bbbb8055f8baaf4ea3d45fcfca50d296b39537b56605a97d205aeca61d08c767eb1000cd53ce1d752d62093579d367729e7a5dc868cc620122264036770ca6eafd7bf91acfeeb32384b06b9b9de901a6e4300a17750f9a93b123a762950633fe0e507065c3443b147b14642b21823b57f468fc7d7579fe8bf6840180dfa3010176352f7f408ca088c9e25fe05074a42772e4b29a10c9395a340ce93820cde092000001207a636173685f636c69656e745f6261636b656e643a6f75747075745f696e666f12028c3b8fdb49a840dbade76e60189071b10001dc95473287e4f28b8d89a2e5ac202517aac261b319b8795c523f9cc05146e42803c0fc15007352a72436c859568abff93b0cffecadd42fbe93a230444c3827506dcfc013130001b09320715d10acd83e4ba8bbbe053d421c0f4fdefa830eb582739af87e5cb600";

        let seed = "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

        let seed = hex::decode(seed).unwrap();

        let ufvk = derive_ufvk(&seed).unwrap();
        // println!("ufvk: {}", ufvk);

        let seed_fingerprint = calculate_seed_fingerprint(&seed).unwrap();
        // println!("seed_fingerprint: {:?}", hex::encode(seed_fingerprint));

        let pczt = Pczt::parse(&hex::decode(pczt).unwrap()).unwrap();
        // println!("rk: {}", hex::encode(pczt.orchard().actions()[0].spend().rk()));
        // //6122d6b5ddcc9eb600a4cedb98932b3a7edf6e8b51bc4478b296450bda68c506
        // println!("alpha: {:?}", hex::encode(pczt.orchard().actions()[0].spend().alpha().unwrap()));

        let result = sign_pczt(&pczt, &seed).unwrap();

        // println!("result: {:?}", hex::encode(result));
    }
}
