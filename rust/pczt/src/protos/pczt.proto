syntax = "proto3";

package pczt;

message PartiallyCreatedTransaction {
    // The version of this wire format, for storage.
    uint32 protoVersion = 1;
    PcztGlobal global = 2;
    optional PcztTransparent transparent = 3;
    optional PcztSapling sapling = 4;
    optional PcztOrchard orchard = 5;
}

message PcztGlobal {
    uint32 txVersion = 1;
    
    //is versionGroupId still needed?
    fixed32 versionGroupId = 2;
    
    uint32 lockTime = 3;
    uint32 expiryHeight = 4;
    uint32 consensusBranchId = 5;
    uint32 networkId = 6;
}

message PcztTransparent {
    repeated PcztTransparentInput inputs = 1;
    repeated PcztTransparentOutput outputs = 2;
}

message PcztTransparentInput{
    bytes pubkey = 1;
    PcztTransparentCoin previousCoin = 2;
    PcztTransparentOutpoint previousOutpoint = 3;
    PcztDerivationPath path = 4;
    repeated bytes signatures = 5;
}

message PcztTransparentCoin {
    uint64 value = 1;
    bytes scriptPubkey = 2;
}

message PcztTransparentOutput{
    PcztTransparentCoin coin = 1;
    
    // if an output has path, it is a change output
    optional PcztDerivationPath path = 2;
}

message PcztTransparentOutpoint {
    bytes txHash = 1;
    uint32 index = 2;
}

message PcztDerivationPath {
    // the 32 bytes seed fingerprint;
    bytes seedFingerprint = 1;
    
    // for orchard it should be pk_d(DiversifiedTransmissionKey)
    // hardware wallet should check this with the derived key from it self.
    bytes pubkey = 2;
    
    repeated PathComponent pathComponents = 3;
}

message PathComponent {
    uint32 value = 1;
    bool harden = 2;
}

message PcztOrchard {
    uint32 flag = 1;
    int64 valueBalance = 2;
    bytes anchor = 3;
    repeated PcztOrchardAction actions = 4;
}

message PcztOrchardAction {
    bytes nf = 1;
    bytes rk = 2;
    bytes cmx = 3;
    bytes epk = 4;
    bytes encCipherText = 5;
    bytes outCipherText = 6;
    bytes cv_net = 7;

    bytes alpha = 8;
    
    //the serilized spend note(rho, rseed, value, receipent) of this action, to verify the nf and cmx in this action.
    bytes spend_note = 9;
    PcztDerivationPath path = 10;
    repeated bytes signatures = 11;
}

message PcztSapling {
    int64 valueBalance = 1;
    repeated PcztSaplingSpend spends = 2;
    repeated PcztSaplingOutput outputs = 3;
}

message PcztSaplingSpend {
    bytes nf = 1;
    bytes cv = 2;
    bytes rk = 3;
    bytes proof = 4;

    bytes anchor = 5;

    bytes alpha = 6;

    PcztDerivationPath path = 7;
    repeated bytes signatures = 8;
}

message PcztSaplingOutput {
    bytes cv = 1;
    bytes cmu = 2;
    bytes epk = 3;
    bytes encCipherText = 4;
    bytes outCipherText = 5;

    // if an output has path, it is a change output
    optional PcztDerivationPath path = 6;
}
