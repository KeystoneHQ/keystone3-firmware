// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartiallyCreatedTransaction {
    /// The version of this wire format, for storage.
    #[prost(uint32, tag = "1")]
    pub proto_version: u32,
    #[prost(message, optional, tag = "2")]
    pub global: ::core::option::Option<PcztGlobal>,
    #[prost(message, optional, tag = "3")]
    pub transparent: ::core::option::Option<PcztTransparent>,
    #[prost(message, optional, tag = "4")]
    pub sapling: ::core::option::Option<PcztSapling>,
    #[prost(message, optional, tag = "5")]
    pub orchard: ::core::option::Option<PcztOrchard>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PcztGlobal {
    #[prost(uint32, tag = "1")]
    pub tx_version: u32,
    /// is versionGroupId still needed?
    #[prost(fixed32, tag = "2")]
    pub version_group_id: u32,
    #[prost(uint32, tag = "3")]
    pub lock_time: u32,
    #[prost(uint32, tag = "4")]
    pub expiry_height: u32,
    #[prost(uint32, tag = "5")]
    pub consensus_branch_id: u32,
    #[prost(uint32, tag = "6")]
    pub network_id: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PcztTransparent {
    #[prost(message, repeated, tag = "1")]
    pub inputs: ::prost::alloc::vec::Vec<PcztTransparentInput>,
    #[prost(message, repeated, tag = "2")]
    pub outputs: ::prost::alloc::vec::Vec<PcztTransparentOutput>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PcztTransparentInput {
    #[prost(bytes = "vec", tag = "1")]
    pub pubkey: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub previous_coin: ::core::option::Option<PcztTransparentCoin>,
    #[prost(message, optional, tag = "3")]
    pub previous_outpoint: ::core::option::Option<PcztTransparentOutpoint>,
    #[prost(message, optional, tag = "4")]
    pub path: ::core::option::Option<PcztDerivationPath>,
    #[prost(bytes = "vec", repeated, tag = "5")]
    pub signatures: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PcztTransparentCoin {
    #[prost(uint64, tag = "1")]
    pub value: u64,
    #[prost(bytes = "vec", tag = "2")]
    pub script_pubkey: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PcztTransparentOutput {
    #[prost(message, optional, tag = "1")]
    pub coin: ::core::option::Option<PcztTransparentCoin>,
    /// if an output has path, it is a change output
    #[prost(message, optional, tag = "2")]
    pub path: ::core::option::Option<PcztDerivationPath>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PcztTransparentOutpoint {
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "2")]
    pub index: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PcztDerivationPath {
    /// the 32 bytes seed fingerprint;
    #[prost(bytes = "vec", tag = "1")]
    pub seed_fingerprint: ::prost::alloc::vec::Vec<u8>,
    /// for orchard it should be pk_d(DiversifiedTransmissionKey)
    /// hardware wallet should check this with the derived key from it self.
    #[prost(bytes = "vec", tag = "2")]
    pub pubkey: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "3")]
    pub path_components: ::prost::alloc::vec::Vec<PathComponent>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PathComponent {
    #[prost(uint32, tag = "1")]
    pub value: u32,
    #[prost(bool, tag = "2")]
    pub harden: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PcztOrchard {
    #[prost(uint32, tag = "1")]
    pub flag: u32,
    #[prost(int64, tag = "2")]
    pub value_balance: i64,
    #[prost(bytes = "vec", tag = "3")]
    pub anchor: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "4")]
    pub actions: ::prost::alloc::vec::Vec<PcztOrchardAction>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PcztOrchardAction {
    #[prost(bytes = "vec", tag = "1")]
    pub nf: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub rk: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub cmx: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub epk: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "5")]
    pub enc_cipher_text: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "6")]
    pub out_cipher_text: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "7")]
    pub cv_net: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "8")]
    pub alpha: ::prost::alloc::vec::Vec<u8>,
    /// the serilized spend note(rho, rseed, value, receipent) of this action, to verify the nf and cmx in this action.
    #[prost(bytes = "vec", tag = "9")]
    pub spend_note: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "10")]
    pub path: ::core::option::Option<PcztDerivationPath>,
    #[prost(bytes = "vec", repeated, tag = "11")]
    pub signatures: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PcztSapling {
    #[prost(int64, tag = "1")]
    pub value_balance: i64,
    #[prost(message, repeated, tag = "2")]
    pub spends: ::prost::alloc::vec::Vec<PcztSaplingSpend>,
    #[prost(message, repeated, tag = "3")]
    pub outputs: ::prost::alloc::vec::Vec<PcztSaplingOutput>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PcztSaplingSpend {
    #[prost(bytes = "vec", tag = "1")]
    pub nf: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub cv: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub rk: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub proof: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "5")]
    pub anchor: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "6")]
    pub alpha: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "7")]
    pub path: ::core::option::Option<PcztDerivationPath>,
    #[prost(bytes = "vec", repeated, tag = "8")]
    pub signatures: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PcztSaplingOutput {
    #[prost(bytes = "vec", tag = "1")]
    pub cv: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub cmu: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub epk: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub enc_cipher_text: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "5")]
    pub out_cipher_text: ::prost::alloc::vec::Vec<u8>,
    /// if an output has path, it is a change output
    #[prost(message, optional, tag = "6")]
    pub path: ::core::option::Option<PcztDerivationPath>,
}
